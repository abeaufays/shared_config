[init]
	defaultBranch = main
[core]
	excludesFile = ~/.gitignore.global
    editor = code --wait 
[branch]
	sort = -committerdate
[diff]
	algorithm = histogram
	colorMoved = plain
	mnemonicPrefix = true
	renames = true
[rebase]
    autosquash = true
    autostash = true
	updateRefs = true
[fetch]
	prune = true
	pruneTags = true
[push]
	autoSetupRemote = true
[alias]
    main-branch = "!git symbolic-refs refs/remotes/origin/HEAD | cut -d'/' -f4"
    rbi = rebase -i
    ame = commit --amend
    amne = commit --amend --no-edit
    pf = push --force-with-lease
    fp = pf
	wip = commit --message='TMP: [skip ci]' --allow-empty --no-verify
    sw = switch

    # Fixup on with a GUI selector (requires fzf + not on main branch)
	fix = "!git log `git merge-base @ $(git main-branch)`..@ --pretty=format:'%h %s' | fzf | cut -c -7 | xargs git commit --fixup"
    # Alternative without fzf: add reference to commit 
    # fix = commit --fixup

	# Switch with a GUI selector (requires fzf)
    swf = "!git branch | fzf | xargs git switch"
    # Alternative without fzf: Switch on a branch with partial name
    # swf = "!f() { git branch | grep $1 | xargs git switch; }; f"

	# Update main then rebase on it
    rbm = "!git fetch origin $(git main-branch):$(git main-branch); git rebase $(git main-branch)"
    # Rebase interactive on all that is new to current branch (requires not being on main branch)
	rba = "!git rebase -i --autosquash `git merge-base @ $(git main-branch)`"
    # Update main then create new branch from it
	nbr = "!f() { git fetch origin $(git main-branch):$(git main-branch); git switch -c $1 $(git main-branch); }; f"
    spu = stash push -u
	spo = stash pop
[include]
    path = ~/.gitconfig.user